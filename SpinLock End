namespace ServerCore
{
  class SpinLock                                                                                     //무한정으로 계속 기다림.
    {
        volatile int _locked = 0;                                                             

        public void Acquire()          
        {
            while (true)
            {
                //int original = Interlocked.Exchange(ref _locked, 1);                                //Interlocked.Exchange는 원자성을 갖고, 본래의 값(0)을 반환하고 설정한 값(1)으로 변환하는 작업을 한번에 함.
                //if (original == 0)                                                                  //이미 _locked를 true로 가져왔기 떄문에 이후의 while문 내부는 원자성을 갖고있다고 봄. 다른곳에서 참조 불가능 모데궁
                //    break;                                                                          //상태를 가져오고 문을 잠근다음 볼일을 보러감.

                int expected = 0;                                                                     //예상한 값을 설정.
                int desired = 1;                                                                      //원하는 변환값 설정.
                if(Interlocked.CompareExchange(ref _locked, desired, expected) == expected)           //Interlocked.CompareExchage로 원자성을 가져옴.
                    break;

                //쉬다옴 랜덤으로 일정 시간 쉬었다가 다시 가서 화장실이 잠겨있는지 확인. 
                Thread.Sleep(1); // 1ms 정도 무조건 쉼.
                Thread.Sleep(0); // 조건부 양보. 나보다 우선순위가 높은 애들한테만 양보 가능. 나랑 같거나 낮은 애들은 양보 안하고 내가 실행.
                Thread.Yield();  // 즉시 양보. 나보다 우선순위가 높은 애든 낮은 애든 상관없이 무조건 양보. / 실행가능한 애가 없을 경우 내가 다시 실행됨.
            }
        }

        public void Release() 
        {
            _locked = 0;                                                                               //잠금 해제 다른사람이 화장실 사용 가능.
        }
    }
    class Program
    {
        static int _num = 0;
        static SpinLock SpinLock = new SpinLock();                  //스핀락 방법을 전수받음.

        static void Thread_1()
        {
            for(int i=0; i<100000; i++)
            {
                SpinLock.Acquire();                                 
                _num++;                                              //Acquire와 Release 사이의 어떠한 코드가 와도 이미 _locked는 true이기 때문에 계속 원자성을 지님. 즉 _num++ 이외의 다른 코드가 연속되어도 됨.
                SpinLock.Release();                                  //모데궁 종료.
            }
        }
        static void Thread_2()
        {
            for (int i = 0; i < 100000; i++)
            {
                SpinLock.Acquire();
                _num--;
                SpinLock.Release();
            }
        }


        static void Main(string[] args)
        {
            Task t1 = new Task(Thread_1);
            Task t2 = new Task(Thread_2);

            t1.Start();
            t2.Start();

            Task.WaitAll(t1, t2);

            Console.WriteLine(_num);

        }
    }
}
