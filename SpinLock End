namespace ServerCore
{
  class SpinLock                       
    {
        volatile int _locked = 0;                                                             

        public void Acquire()          
        {
            while (true)
            {
                //int original = Interlocked.Exchange(ref _locked, 1);                                //Interlocked.Exchange는 원자성을 갖고, 본래의 값(0)을 반환하고 설정한 값(1)으로 변환하는 작업을 한번에 함.
                //if (original == 0)                                                                  //이미 _locked를 true로 가져왔기 떄문에 이후의 while문 내부는 원자성을 갖고있다고 봄. 다른곳에서 참조 불가능 모데궁
                //    break;                                                                          //상태를 가져오고 문을 잠근다음 볼일을 보러감.

                int expected = 0;                                                                     //예상한 값을 설정.
                int desired = 1;                                                                      //원하는 변환값 설정.
                if(Interlocked.CompareExchange(ref _locked, desired, expected) == expected)           //Interlocked.CompareExchage로 원자성을 가져옴.
                    break;
            }
        }

        public void Release() 
        {
            _locked = 0;                                                                               //잠금 해제 다른사람이 화장실 사용 가능.
        }
    }
    class Program
    {
        static int _num = 0;
        static SpinLock SpinLock = new SpinLock();                  //스핀락 방법을 전수받음.

        static void Thread_1()
        {
            for(int i=0; i<100000; i++)
            {
                SpinLock.Acquire();                                 
                _num++;                                              //혹여나 _num++ 이후의 다른 코드가 오게되면 그 즉시 원자성을 잃게됨.
                SpinLock.Release();                                  //모데궁 종료.
            }
        }
        static void Thread_2()
        {
            for (int i = 0; i < 100000; i++)
            {
                SpinLock.Acquire();
                _num--;
                SpinLock.Release();
            }
        }


        static void Main(string[] args)
        {
            Task t1 = new Task(Thread_1);
            Task t2 = new Task(Thread_2);

            t1.Start();
            t2.Start();

            Task.WaitAll(t1, t2);

            Console.WriteLine(_num);

        }
    }
}
